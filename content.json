{"meta":{"title":"Alice","subtitle":null,"description":null,"author":"John Doe","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-01-02T06:50:17.000Z","updated":"2019-01-02T06:50:44.000Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"欢迎来到这个地方"}],"posts":[{"title":"实战Taro自定义的下拉刷新和上拉加载","slug":"实战Taro自定义的下拉刷新和上拉加载","date":"2019-01-30T06:03:30.000Z","updated":"2019-01-30T06:03:30.000Z","comments":true,"path":"2019/01/30/实战Taro自定义的下拉刷新和上拉加载/","link":"","permalink":"http://yoursite.com/2019/01/30/实战Taro自定义的下拉刷新和上拉加载/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"bug收集","slug":"bug收集","date":"2019-01-30T01:32:44.000Z","updated":"2019-05-09T03:14:24.855Z","comments":true,"path":"2019/01/30/bug收集/","link":"","permalink":"http://yoursite.com/2019/01/30/bug收集/","excerpt":"","text":"如果项目出现以下报错，别多想，重新新建一个项目，重新装依赖啥的，比你解决这个error要来的快，搞了2个钟都没搞出来的我，心疼自己。。。 ReactObjects are not valid as a React child (found: object with keys {counter, auth}). If you meant to render a collection of children, use an array instead.将reducer合并的时候，要注意将之前在装饰器里面写的state要变成取单个属性，不然会报错 复杂数据结构的深拷贝和浅拷贝简单的数组进行深拷贝，可以使用slice和connact，但是遇到复杂的数据结构进行深拷贝的时候，比如说数组里面嵌套了数组，这时候只是一层外面数组的slice深拷贝，并不能解决内部数组还是引用的同个内存地址，导致对复制出来的数据进行修改的时候，会影响到原来的数据，这个时候，就可以通过下面方法12$ /*深拷贝*/$ this.menu_routes = JSON.parse(JSON.stringify(this.routes)) 在项目中，会遇到对路由文件的操作，但是页面不刷新的时候，会发现路由文件被进行多次操作，导致路由文件的数据发生了变化，这是不对的，我们希望每次登陆都会获取一份新的路由数据，而不是上次操作后的路由数据。","categories":[],"tags":[]},{"title":"JS中的require和import区别","slug":"JS中的require和import区别","date":"2019-01-23T04:10:29.000Z","updated":"2019-01-23T04:13:26.000Z","comments":true,"path":"2019/01/23/JS中的require和import区别/","link":"","permalink":"http://yoursite.com/2019/01/23/JS中的require和import区别/","excerpt":"","text":"在研究react和webpack的时候，经常看到在js文件中出现require，还有import，这两个都是为了JS模块化编程使用。CSS的是@import原文链接：JS中的require和import区别","categories":[],"tags":[]},{"title":"koa随堂笔记","slug":"随堂笔记","date":"2019-01-23T02:33:28.000Z","updated":"2019-01-30T09:58:00.000Z","comments":true,"path":"2019/01/23/随堂笔记/","link":"","permalink":"http://yoursite.com/2019/01/23/随堂笔记/","excerpt":"装NVM的时候装出问题的时候，重新卸载，node无法使用的问题装NVM的时候装出问题的时候，重新卸载，node无法使用的时候先安装node，再使用node12$ nvm install stable /*安装最新版的node*/$ nvm use 10.15.0 /*版本号*/","text":"装NVM的时候装出问题的时候，重新卸载，node无法使用的问题装NVM的时候装出问题的时候，重新卸载，node无法使用的时候先安装node，再使用node12$ nvm install stable /*安装最新版的node*/$ nvm use 10.15.0 /*版本号*/ 然后这时候，你会发现webstorm的node使用不了，那是因为node安装的路径变了，得重新在webstorm里更换nodejs的路径然后这时候，你又发现你的hexo命令行又不能使用了，这时候，又要更改下hexo的环境变量 断言assert判断一个代码的执行结果是否符合预期，如果不符合，就打印出检验失败的日志，方便我们在开发代码或运行的代码的时候，去了解个地方代码运行的结果，或运行错误，调用错误，入参不合法。 vary()好像很叼纯函数纯函数：不依赖其他，只有入参和return，非常安全 koa里面的compose的作用koa的compose就是将中间件串联起来运行，当执行next()的时候，就是触发第二个中间件的时候，将执行权交给第二个中间件，所以这就是尾递归 递归调用对堆栈的压力 使用puppeteer做爬虫互联网的各种请求其实都是基于各种协议的请求和返回，比如说基于tcp/IP上面的http请求，puppeteer在本地模拟了一个浏览器来请求网页，来爬一下不太好爬的数据，主要是保持主进程的健壮性，分配给了子进程来处理这些事情。 了解进程的9个问题同步异步、阻塞非阻塞如果一个进程在等待另一个进程的完成，这叫做同步阻塞，如果一个进程在等待另一个进程的完成，并且不间断的来轮询这个进程有没有完成，如果这个进程还没完成，他就去做别的事情，这叫做同步非阻塞。这两种情况，等待的进程都是比较被动的，必须自己去轮询在工作的进程是否已经完成如果在进程正在运行的时候，注册一个回调函数，这个进程已经完成，就执行回调，通知另一个进程来执行，这就叫做异步非阻塞如果我已经注册了一个回调函数，但是进程还是在等待另一个进程的完成，这就叫做异步阻塞对于一个系统来说，调用方如果需要被调用方完成手头的事情，并且一直等待他结束，这种调用方式就是同步的，如果调用方不需要一直等待被调用方来响应，那这种调用方式就是异步的，实现这种异步可以通过调用方的主动轮询，也可以通过被调用方的主动通知，也就是执行调用方之前注册号的回调。而阻塞和非阻塞，是指在调用的过程中，调用方在获得消息的状态，如果这个获取是什么都不能做，必须要等待的话，那么就是阻塞，反之就是非阻塞，往往同步的操作会导致阻塞，异步的操作不会发生阻塞，但不是100%如此。一句话收尾：同步异步是过程在于有无消息通知的机制，调用方是主动等待还是被动通知进度，阻塞非阻塞是状态是调用方在获取结果的时候，是干等还是互不干扰，而异步非阻塞就是nodejs的一大卖点五分钟，捋清同步异步阻塞非阻塞并发并行 nodejs的Event Loopnodejs的事件循环机制就是允许nodejs去执行一些nodejs的异步非阻塞的操作这样的一个策略或者机制，事件处理机制有顺序，其中第一层是timers，定时器的回调函数就会在这层执行，","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"nvm","slug":"nvm","permalink":"http://yoursite.com/tags/nvm/"},{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"webstorm","slug":"webstorm","permalink":"http://yoursite.com/tags/webstorm/"}]},{"title":"2019年学习的目标","slug":"2019年学习的目标","date":"2019-01-21T01:35:22.000Z","updated":"2019-01-23T08:51:02.000Z","comments":true,"path":"2019/01/21/2019年学习的目标/","link":"","permalink":"http://yoursite.com/2019/01/21/2019年学习的目标/","excerpt":"","text":"今年想了解的技能从一开始接触微信小程序到后面的taro框架，从一开始接触node到后面的koa框架，GraphQL2018年年底买了一套《你不知道的js》，今年年初也打算看完，并且重复阅读，前端之路走的好漫长。","categories":[],"tags":[]},{"title":"vue路由的两种模式hash和history的区别","slug":"vue路由的两种模式hash和history的区别","date":"2019-01-15T03:36:12.000Z","updated":"2019-01-15T03:36:12.000Z","comments":true,"path":"2019/01/15/vue路由的两种模式hash和history的区别/","link":"","permalink":"http://yoursite.com/2019/01/15/vue路由的两种模式hash和history的区别/","excerpt":"","text":"项目遇到问题，用history打包出现问题：hash路由的话，我们只请求了头部#前面的url路径，其余的#后面的，只是我们的前端路由，用来加载不同的组件，我们并不是通过url来请求后台数据的，我们是通过组件的生命周期调用接口，请求后台数据，用history就会产生将整个url都用做http请求，然后向后台请求数据，当页面刷新的时候，用history就会出现404页面查找不到，这个时候就需要后台配置，将所有的情况，都重定向到index.html","categories":[],"tags":[]},{"title":"实战Taro出现的坑","slug":"实战Taro出现的坑","date":"2019-01-10T08:46:00.000Z","updated":"2019-01-10T08:46:00.000Z","comments":true,"path":"2019/01/10/实战Taro出现的坑/","link":"","permalink":"http://yoursite.com/2019/01/10/实战Taro出现的坑/","excerpt":"","text":"1、不能使用push（非常的不方便）12345678910111213$ /*替换方法*/$ let length=this.state.posts.length let posts=this.state.posts posts[length]=&#123; id:1, title:'次子大婚'+length, date:'2017-12-12 12:30', count:'3655', dateCN:'农历大年初一' &#125; this.setState(&#123; posts &#125;) 2、引用本地静态资源，用import进去12$ import searchPng from '../../images/right.png'$ &lt;Image src=&#123;searchPng&#125; className='right'&gt;&lt;/Image&gt; 3、新增page的时候，需要主动在app.tsx里面添加page页面","categories":[],"tags":[]},{"title":"实战Taro父子组件的通讯问题","slug":"实战Taro父子组件的通讯问题","date":"2019-01-07T08:59:30.000Z","updated":"2019-01-07T08:59:30.000Z","comments":true,"path":"2019/01/07/实战Taro父子组件的通讯问题/","link":"","permalink":"http://yoursite.com/2019/01/07/实战Taro父子组件的通讯问题/","excerpt":"其实不叫做父子组件，是page和component之间的通讯，但是想了想，组件也是可以嵌套使用，还是用父子组件来的好 父组件向子组件传递参数主要是通过props来传递属性，暂不细说","text":"其实不叫做父子组件，是page和component之间的通讯，但是想了想，组件也是可以嵌套使用，还是用父子组件来的好 父组件向子组件传递参数主要是通过props来传递属性，暂不细说 子组件触发父组件传递过去的函数同样是通过props传递，但是传递的类型不是属性，而是函数1$ onCallbackParent=&#123;this.goToDetail.bind(this,item)&#125; /*父组件*/ 然后在子组件里面触发这个函数123$ &lt;View className='list' onClick=&#123;this.props.onCallbackParent&#125;&gt;$ ...$ &lt;/View&gt; /*子组件*/ 这里需要注意的是：1、父组件传递函数的时候，必须要加上‘on’ 子组件触发父组件传递过去的函数的作用主要是为了能够将逻辑都写在父组件里，保证子组件的简单，这样子后期复用性高","categories":[],"tags":[]},{"title":"欢迎来到我的博客","slug":"欢迎来到我的博客","date":"2018-12-29T02:36:12.000Z","updated":"2019-01-02T06:37:58.000Z","comments":true,"path":"2018/12/29/欢迎来到我的博客/","link":"","permalink":"http://yoursite.com/2018/12/29/欢迎来到我的博客/","excerpt":"欢迎来到我的博客","text":"欢迎来到我的博客","categories":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/categories/随笔/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://yoursite.com/tags/随笔/"}]}]}